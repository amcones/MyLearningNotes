## 上下文无关语法

一个上下文无关文法$G$是一个四元式$G=(V_T,V_N,S,P)$，其中
- $V_T$：终结符集合（非空）
- $V_N$：非终结符集合（非空），且$V_T\cap V_N=\varnothing$
- $S$：文法的开始符号，$S\in V_N$
- $P$：产生式集合（有限），每个产生式形式为$P\to \alpha,P\in V_N,\alpha \in (V_T \cup V_N)^*$
- $S$至少在某个产生式左边出现一次
可以把相同模式的产生式合并在一起简写。
称$\alpha A \beta$直接推出$\alpha \gamma \beta$，即
$$
\alpha A\beta \Rightarrow \alpha \gamma \beta
$$
仅当$A\to \gamma$是一个产生式，且$\alpha,\beta\in (V_T\cup V_N)^*$
如果一个产生式能经过若干次直接推导得到另一个产生式，称这个序列是一个**推导**，称$\alpha_1$可以推导出$\alpha_n$。
$\alpha_1 \stackrel{+}{\Rightarrow} \alpha_n$表示从$\alpha_1$经过1步或若干步可以推导出$\alpha_n$，而$\alpha_1\stackrel{*}{\Rightarrow}\alpha_n$表示经过0步或若干步可以推导出。
假定$G$是一个文法，$S$是它的开始符号。如果$S\stackrel{*}{\Rightarrow}\alpha$，称$\alpha$是一个**句型**。仅含终结符号的句型是一个**句子**。文法$G$所产生的句子的全体是一个**语言**，将它记为$L(G)$。
$$
L(G)=\{\alpha|S\stackrel{+}{\Rightarrow}\alpha,\alpha\in {V_T}^*\}
$$
>通过文法的定义引出句型、句子的定义，从离散数学角度定义语言。由开始符星号推导得到的都是句型，只包含终结符的句型是句子，文法产生句子全体是语言。


## 文法

有0型，1型，2型，3型文法。短语文法是0型（$\alpha \to \beta,\alpha \in {(V_T\cup V_N)}^*,\beta \in {(V_T\cup V_N)}^*$，$\alpha$至少有一个非终结符，即左右都是终结符和非终结符组成的任意串）；上下文有关文法是1型（$\alpha$的长度小于等于$\beta$，$\epsilon$例外）；上下文无关文法是2型（左边长度为1），正规文法是3型（右边除了终结符只能有一个非终结符，根据非终结符位置分左线性正规文法和右线性正规文法）。

最左推导，最右推导：每次直接推导替换最左（右）的非终结符。

如果一个文法产生的一个句子对应两颗不同的语法树，则说这个文法是**二义的**。一个语言是二义的，如果对它不存在无二义性的文法。

## 正规（则）表达式

对于字母表$\Sigma$ ，我们感兴趣的是它的一些特殊字集，即**正规集**。使用正则表达式表示正规集。

> 通俗来说，我们都知道可以用正则表达式描述一个规则去匹配符合规则的字符串。而符合这个规则的字集就是正规集。

正则表达式和正规集的递归定义：
1. $\epsilon$ 和 $\phi$ 都是$\Sigma$ 上的正规式
2. 任何$a \in \Sigma$ 都是$\Sigma$ 上的正规式
3. 假设$U$和$V$都是$\Sigma$上的正规式，它们表达的正规式分别为$L(U)$和$L(V)$，那么$(U|V),(U\cdot V),(U)^*$ 都是正规式。

主要就是三种运算，合取，连接积和闭包（任意有限次自重复连接）。优先顺序是上述顺序递增。

## DFA

一个DFA是一个五元式
$$
M=(S,\Sigma,\delta,s_0,F)
$$
1. $S$是一个有限集，每个元素是一个**状态**。
2. $\Sigma$有穷字母表，每个元素是一个输入字符。
3. $\delta$从$S\times \Sigma$到$S$的单值映射。$\delta(s,a)=s'$，意味着现行状态为$s$，输入字符为$a$，将转移到下一个状态$s'$，称为$s$的一个后继状态。
4. $s_0\in S$，唯一初态。
5. $F\subseteq S$，是一个终态集。  

而NFA的主要区别是$\delta$是一个映照，即对应着多个状态。同时初态也不唯一。

每个正规式都可以转化为一个NFA。

对于每个NFA，存在一个等价DFA。将NFA确定化为DFA的方法称为**子集法**。

子集法的具体做法：
1. 重复使用三种运算的替换规则拆分状态
2. 构造一张表，表的第一行第一列是从初态出发，经过任意个$\epsilon$能够到达的状态。然后将$\Sigma$中的每个字符分别输入这个状态，得到新的状态。如果这些状态没有出现在第一列中过，就把它写在下一行的第一列，直到所有状态都已经操作过。
3. 重新命名状态子集，根据新的状态转换矩阵画出DFA。

正规式和DFA是等价的。

## DFA的化简

DFA主要存在三种化简算法，下面介绍教材上使用的方法：
1. 将DFA中的所有状态分为终态和非终态两个集合
2. 对于每个集合，重复将字符集中的字符输入。如果集合中每一个元素经过同一个字符到达的状态相同，那么这些元素等价，可以合并，否则对这个集合继续拆分，直到这个集合中元素等价或者只剩下一个元素
3. 重新命名集合，并重新绘制状态转换矩阵，最后画出DFA。

## 后记

可以看到正规表达式与DFA是等价的，并且存在算法将它们进行互相转换。可以将正规表达式转为DFA，然后使用图论进行存储、操作等。我并不知道各大语言中的正规表达式是如何实现的，但从这一章我们可以看出其中的思路。有了正规表达式，我们就可以分析出文本当中所有的模式串。而词法分析的目标，就是将代码中所有指定类型的字符串匹配出来。

下一步就是**语法分析**了，也就是新手学编程时编译器总会报错的这一功能。