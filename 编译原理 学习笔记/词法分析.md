在我的教材中，这是第三章。而前两章主要是对于编译原理的介绍与形式语言的介绍，而第二章中对文法进行了介绍，然而复杂的离散数学定义我看的并不是很懂，所以直接进入第三章的重点。

## 正规（则）表达式

对于字母表$\Sigma$ ，我们感兴趣的是它的一些特殊字集，即**正规集**。使用正则表达式表示正规集。

> 通俗来说，我们都知道可以用正则表达式描述一个规则去匹配符合规则的字符串。而符合这个规则的字集就是正规集。

正则表达式和正规集的递归定义：
1. $\epsilon$ 和 $\phi$ 都是$\Sigma$ 上的正规式
2. 任何$a \in \Sigma$ 都是$\Sigma$ 上的正规式
3. 假设$U$和$V$都是$\Sigma$上的正规式，它们表达的正规式分别为$L(U)$和$L(V)$，那么$(U|V),(U\cdot V),(U)^*$ 都是正规式。

主要就是三种运算，合取，连接积和闭包（任意有限次自重复连接）。优先顺序是上述顺序递增。

## DFA

一个DFA是一个五元式
$$
M=(S,\Sigma,\delta,s_0,F)
$$
1. $S$是一个有限集，每个元素是一个**状态**。
2. $\Sigma$有穷字母表，每个元素是一个输入字符。
3. $\delta$从$S\times \Sigma$到$S$的单值映射。$\delta(s,a)=s'$，意味着现行状态为$s$，输入字符为$a$，将转移到下一个状态$s'$，称为$s$的一个后继状态。
4. $s_0\in S$，唯一初态。
5. $F\subseteq S$，是一个终态集。  

而NFA的主要区别是$\delta$是一个映照，即对应着多个状态。同时初态也不唯一。

每个正规式都可以转化为一个NFA。

对于每个NFA，存在一个等价DFA。将NFA确定化为DFA的方法称为**子集法**。

子集法的具体做法：
1. 重复使用三种运算的替换规则拆分状态
2. 构造一张表，表的第一行第一列是从初态出发，经过任意个$\epsilon$能够到达的状态。然后将$\Sigma$中的每个字符分别输入这个状态，得到新的状态。如果这些状态没有出现在第一列中过，就把它写在下一行的第一列，直到所有状态都已经操作过。
3. 重新命名状态子集，根据新的状态转换矩阵画出DFA。

正规式和DFA是等价的。

## DFA的化简

DFA主要存在三种化简算法，下面介绍教材上使用的方法：
1. 将DFA中的所有状态分为终态和非终态两个集合
2. 对于每个集合，重复将字符集中的字符输入。如果集合中每一个元素经过同一个字符到达的状态相同，那么这些元素等价，可以合并，否则对这个集合继续拆分，直到这个集合中元素等价或者只剩下一个元素
3. 重新命名集合，并重新绘制状态转换矩阵，最后画出DFA。

## 后记

可以看到正规表达式与DFA是等价的，并且存在算法将它们进行互相转换。可以将正规表达式转为DFA，然后使用图论进行存储、操作等。我并不知道各大语言中的正规表达式是如何实现的，但从这一章我们可以看出其中的思路。有了正规表达式，我们就可以分析出文本当中所有的模式串。而词法分析的目标，就是将代码中所有指定类型的字符串匹配出来。

下一步就是**语法分析**了，也就是新手学编程时编译器总会报错的这一功能。