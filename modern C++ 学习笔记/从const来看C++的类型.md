`const`在各大语言中是个很常见的概念，由于没有指针和引用，`const`或者说`final`在Java中就非常简单和直觉。然而，有了指针之后，一切都变了。

## C++的噩梦

大家看到`const`，觉得我说它是噩梦，估计是不信的。当然，我说的如果仅仅只是`const int a = 1`，那什么问题也没有。那么，接下来开始：

### 文件间const

C++为了承担起工程，首先必须支持多文件。关于C++多文件的使用，首先需要熟悉**声明**，**定义**，**初始化**，**赋值**的差别。在C++中这是非常复杂的话题，可以单独写一篇，但我还没有写。简单来说：
声明：告诉编译器变量名、变量类型，但没有分配空间。
定义：有变量名、变量类型，且分配了内存。往往伴随初始化。
初始化：对象创建时获得了一个特定值。除了显式的初始化，还有默认的初始化。
赋值：擦除原有的值，赋予新的值。

比较反直觉的是，`int a;`这是一个定义（常常被当做声明），而`extern int a;`这是一个声明。区别在于有没有分配内存。

了解了这些，文件间的`const`就只是一个附带知识。`const`一般只在本文件中生效，除非加上`extern`，它就跨文件了。当然，它只能被赋值一次。

### 对const引用（常量引用）

常量引用是一个广为流传的简称，但实际上并不存在。（不过大家都知道，所以就一直用也没有问题）常量引用是指对`const`变量的引用，意义就是无法通过这个引用改变它绑定的变量的值，哪怕它绑定的变量并不是`const`。

**无论是常量引用还是常量指针，它们都认为自己指向的是常量。**

引用必须和绑定的变量类型一致，**除了两种例外**。其中一种就是`const`引用。为什么`const`引用能够绑定不同的类型？首先考虑一下为什么普通引用不行。

当操作的两个变量类型不一致，编译器会自动生成临时量来统一类型，然后进行操作。如果普通引用绑定的变量类型不一致，那么**普通引用会绑定到生成的临时量**上，而我们对临时量的操作没有意义。那么问题也就解决了，因为`const`引用不能修改绑定的临时量，那么也就没有问题了。

虽然说没有常量引用，但如果从引用本身无法被改变来说，引用都是`const`的，因为引用与原变量之间的绑定关系无论如何都无法改变。

### 顶层const和底层const

由于指针本身是对象（有内存）而引用不是，所以指针本身也可以是`const`的。由此产生了两个概念：
1. 指向const的指针(pointer to const)
表示指针指向的变量是`const`的，而指针本身并不是。
2. 常量指针(const pointer)
表示指针本身是`const`的，而指针指向的变量不是。

这两个问题其实是独立的，但可能由于翻译的问题，经常会被混淆。所以人们更多使用顶层`const`和底层`const`来表达两者的区别。

顶层`const`可以表示任意的对象是常量，而底层`const`与复合类型的基本类型相关。

```c++
int i = 0;
int *const p1 = &i; // 顶层const
const int ci = 42; // 顶层const
const int *p2 = &ci; // 底层const
const int *const p3 = p2; // 靠右的是顶层const，靠左的是底层const
const int &r = ci; // 用于声明引用的const都是底层const（因为没有const引用）
```

一个黄金原则，读变量的类型从右往左读。（Go表示内行，虽然我也不知道是出于什么原则设计的这种读法，就近原则？）对于这种`const int *const p3`，首先靠右的`const`表示`p3`本身是一个常量，`*`表示`p3`是一个指针，那么`p3`它就是一个常量指针。接下来`int`表示这个指针指向的类型是`int`，最靠左的`const`表示这个`int`是`const`的。合起来就是一个指向`const int`的`const`指针。

还有，`*`和`const`都属于类型修饰符，**类型修饰符是声明符的一部分，而不是数据类型的一部分。**

### typedef和const

我相信有很多人对于`typedef`的处理就是把它定义的类型别名给它代回去，但这其实是不对的。
```c++
typedef char *pstring;
const pstring cstr = 0;
const pstring *ps;
```
`pstring`是一个指向`char`的指针，而`cstr`的类型是指向`char`的常量指针。如果把原类型代回去，就变成`const char *cstr`，类型就变成了指向`const char`的指针。（`*`变成修饰`cstr`的了）对此，理解类型最好的方法是**认为离某个标识符最近的修饰对它的影响最大**。

### auto和const 

`auto`一般会忽略掉顶层`const`，同时保留底层`const`，也就是说`auto`的变量更偏向于被修改。如果需要`auto`推断出的类型是一个顶层`const`，则需要明确指出，比如`const auto a`。

C++11中除了`auto`，还提供了`decltype`，其作用是从表达式的数据类型推断出类型给要新声明的变量，但不使用表达式的值来初始化变量。与`auto`不同，它会保留顶层`const`。

`decltype(*p)`的结果是引用（表达式为解引用操作），而非基本类型。

还有一个比较坑的点，`decltype(())`的结果永远是引用，而`decltype()`的结果只有当表达式的类型是引用时才是引用。这意味着加不加括号结果会不一样。

### 总结

其实这篇是借助`const`，深入剖析了一下C++的类型。所以真正复杂的不是`const`，而是类型。很多时候，我写程序用什么类型都依赖于编译器的提示。如果报错，就换一下。好在并没有接触到很多更复杂的类型，一般改一下都能够改对，但这样就失去了自己设计类型的能力。所以有必要学习一下如何理解C++的类型，这是之后设计更复杂程序的基础。