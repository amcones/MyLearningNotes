久闻智能指针大名，然而日常当中裸指针都不太用，更别说智能指针了。然而，作为现代C++的门槛，还是有学习的必要。

## why

裸指针会导致内存泄漏。一个简单的解决想法，就是和对象一样，自动调用析构函数来释放内存。将这样的思想运用在指针上就是智能指针。（所以智能指针本质上是模版类）

## auto_ptr

C++98就支持了`auto_ptr`，但在C++11后就进行了抛弃。主要的原因在于其复制或者赋值都会改变资源的所有权，且不支持对象数组的内存管理。由于重载了指针运算符，可以和普通指针一样使用。

## unique_ptr

取代了`auto_ptr`。用法几乎一致，但增加了限制。
- 基于排他所有权模式，两个指针不能指向同一个资源
- 无法进行左值`unique_ptr`复制构造，也无法进行左值复制赋值操作，但允许临时右值复制构造和赋值
- 保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。
- 在容器中保存指针是安全的

## shared_ptr

由于`unique_ptr`的排他性，第二个指针接管资源时，前一个指针就会变成空指针，访问会导致越界。为了解决这样的问题，使用`shared_ptr`。

使用**引用计数**的方法来管理内存。复制或拷贝时，引用计数+1，析构就-1，计数为0就释放。

**托管模版数组对象，C++17后才开始支持**

看起来很好用，但是要注意循环引用造成无法释放资源，所以要避免交叉使用智能指针。（go太懂了）

## weak_ptr

配合`shared_ptr`引入的一种智能指针，**只可以从一个shared_ptr或另一个weak_ptr对象构造**，它的构造和析构不会引起计数的增加或减少。没有重载指针运算符，但可以使用`lock`获得一个可用的`shared_ptr`对象。

必要的时候可以用`lock`转成共享指针，使用完以后再置NULL即可。（个人感觉上是使用弱指针对共享指针的使用进行一个解耦，把解决问题的时刻推迟，避免在定义共享指针的时候就造成循环引用）

`weak_ptr`的`expired`函数判断当前`weak_ptr`智能指针是否还有托管的对象，有则返回`false`，无返回`true`。

## 总结

裸指针释放的时机是无法控制的，所以使用析构的方式对其进行自动管理。然而引入了智能指针后，虽然提供了解决方案，然而使用的思考成本却进一步提高了。并不是说使用智能指针就一定能够避免内存泄漏，正相反，一旦发生内存泄漏会更难看出来。所以需要注意一些陷阱用法，毕竟内存泄漏仍然是当今最多的bug之一。