久闻智能指针大名，然而日常当中裸指针都不太用，更别说智能指针了。然而，作为现代C++的门槛，还是有学习的必要。

## why

裸指针会导致内存泄漏。一个简单的解决想法，就是和对象一样，自动调用析构函数来释放内存。将这样的思想运用在指针上就是智能指针。（所以智能指针本质上是模版类）

## auto_ptr

C++98就支持了`auto_ptr`，但在C++11后就进行了抛弃。主要的原因在于其复制或者赋值都会改变资源的所有权，且不支持对象数组的内存管理。由于重载了指针运算符，可以和普通指针一样使用。

## unique_ptr

取代了`auto_ptr`。用法几乎一致，但增加了限制。
- 基于排他所有权模式，两个指针不能指向同一个资源
- 无法进行左值`unique_ptr`复制构造，也无法进行左值复制赋值操作，但允许临时右值复制构造和赋值
- 保存指向某个对象的指针，当它本身离开作用域时会自动释放它指向的对象。
- 在容器中保存指针是安全的

## shared_ptr

由于`unique_ptr`的排他性，第二个指针接管资源时，前一个指针就会变成空指针，访问会导致越界。为了解决这样的问题，使用`shared_ptr`。

使用**引用计数**的方法来管理内存。复制或拷贝时，引用计数+1，析构就-1，计数为0就释放。

**托管模版数组对象，C++17后才开始支持**

