## Redis缓存的特点

与其它键值缓存产品相比，有三个特点：

- 运行在内存但可以持久化到磁盘
- 不仅支持Key-Value，还支持List,Set,Sorted set,hash等数据结构
- 支持数据备份，即Master-Slave主从模式的数据备份

## 如何实现Redis的定时机制

Redis服务器是一个 **事件驱动程序** ，服务器需要处理 **文件事件**（套接字操作的抽象） 和 **时间事件** （定时操作的抽象）。Redis定时机制借助时间事件实现。

一个时间事件由三个属性组成：`id`,`when`,`timeProc`。当时间事件到达时，服务器调用相应处理器来处理时间。根据处理器的返回值来判断是定时事件还是周期性事件。

## 单线程Redis为何高效

虽然文件事件处理器单线程运行，但通过 **I/O多路复用程序** 来监听多个套接字，即实现了高性能的网络通信模型，又能与其它单线程模块对接。

> I/O多路复用，即复用1个或少量线程来处理多个连接。联合计网经验，在写程序时对于TCP连接，收到一个请求就新开一个线程，直到请求关闭就销毁线程。而复用少量线程来处理这些请求就是多路复用了。所谓的NIO，指的是同步非阻塞IO。一般是用一个Selector来统一处理请求，Selector开辟几个线程统一去处理请求。而实现非阻塞的关键，是在通信时使用非阻塞的Channel。

## Redis的数据淘汰策略
Redis 内存数据量达到一定限制的时候，就会实行数据淘汰策略（回收策略）。Redis 会根据 maxmemory-policy 配置策略，来决定具体的行为：

- no-eviction：不删除策略，达到最大内存限制时刻，如果需要更多内存，直接返回错误信息；
- allkey-lru：从所有 Key 的哈希表（server.db[i].dict）中随机挑选多个 Key，然后在选到的 Key 中利用 lru 算法淘汰最近最少使用的数据；
- volatile-lru：从已设置过期时间的哈希表（server.db[i].expires）中随机挑选多个 Key，然后在选到的 Key 中用 lru 算法淘汰最近最少使用的数据；
- volatile-random：从已设置过期时间的哈希表（server.db[i].expires）中随机挑选 Key淘汰掉；
- allkey-random：从所有的 Key 的哈希表（server.db[i].dict）中随机挑选数据淘汰；
- volatile-ttl：从已设置过期时间的哈希表（server.db[i].expires）中随机挑选多个 Key，然后在选到的 Key 中选择剩余时间最短的数据淘汰掉。

> LRU指最近最少使用

