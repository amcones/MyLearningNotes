一个事务对他自己的数据块进行操作时，另一个事务不能插足这个数据块。

## 锁的分类

分成6种类型：
- **共享锁（S）**：又叫 **他读锁**。可以并发读取数据，但不能修改数据。也就是当数据资源上存在S锁，所有的事务都不能对该数据进行修改，直到数据读取完成，共享锁释放。
- **排它锁（X）**：又叫 **独占锁**、**写锁**。对数据进行增删改的时候，不允许其他事务操作这块资源，直到X锁释放，从而防止对同一资源进行多重操作。
- **更新锁（U）**：防止 **死锁** ，两个事务对一个数据资源进行先读取再修改的情况下，使用S锁和X锁有时会出现死锁，用U锁就可以避免。资源的U锁一次只分配给一个事务，如果要修改数据，U锁变成X锁，否则变成S锁。
- **意向锁**：表示 SQL Server 需要在 层次结构中的某些底层资源上 获取共享锁或排它锁。例如，放置在 表级 的 共享意向锁 表示事务打算在表中的页或行上放置共享锁。在表级设置意向锁可防止另一个事务随后在包含那一页的表上获取排它锁。意向锁可以提高性能，因为 SQL Server 仅在 表级 检查意向锁来确定事务是否可以安全地获取该表上的锁，而无须检查表中的每行或每页上的锁以确定事务是否可以锁定整个表。意向锁包括意向共享 (IS)、意向排它 (IX) 以及与意向排它共享 (SIX)。
- **架构锁**：在执行 依赖于表架构的操作 时使用。架构锁的类型为：架构修改 (Sch-M) 和架构稳定性 (Sch-S)，执行表的数据定义语言 （DDL）操作（例如添加列或除去表）时使用架构修改锁，当编译查询时，使用架构稳定性锁。
- **大容量更新锁（BU）**：向表中大容量复制数据并指定了 TABLOCK 提示时使用。 大容量更新锁允许进程将数据并发地大容量复制到同一表，同时防止其它不进行大容量复制数据的进程访问该表。

## 事务隔离级别与锁的关系

- 在 **读取未提交** 隔离级别下，读取数据不需要加 **共享锁**，这样就不会跟被修改的数据上的 排他锁 冲突；

- 在 **读取已提交** 隔离级别下，读操作需要加 **共享锁**，但是在语句执行完以后释放共享锁；

- 在 **可重复读** 隔离级别下，读操作需要加 **共享锁**，但是在事务提交之前并不释放共享锁，也就是必须等待事务执行完毕以后才释放共享锁；

- **可串行化** 是限制性最强的隔离级别，因为该级别 **锁定整个范围的键**，并一直持有锁，直到事务完成。

## 死锁

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见的解决死锁的方法

- 如果不同程序并发存取多个表，尽量约定 **以相同的顺序访问表**，可以大大降低死锁机会；
- 在同一个事务中，尽可能做到 **一次锁定所需要的所有资源**，减少死锁产生概率；
- 对于非常容易产生死锁的业务部分，可以尝试使用 **升级锁定颗粒度**，通过 **表级锁** 定来减少死锁产生的概率。

## 乐观锁和悲观锁

**悲观锁**：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作。对于长事务可能严重影响系统的并发处理能力。使用数据库中的锁实现。
**乐观锁**：假定不会发生并发冲突，只在提交操作的时候检查是否违反数据完整性。适合 **读多写少** 的应用场景，这样可以提高吞吐量。一般使用版本号机制或CAS算法实现。