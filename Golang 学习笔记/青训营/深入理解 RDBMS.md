RDBMS ，也就是关系型数据库。虽然大家都对关系型数据库熟悉得不能再熟悉了，然而到了实际开发当中依然会出现各种各样的问题。要想用好关系型数据库，可不简单。

> 就在昨天，我们团队就遇到了数据库中数据不一致的问题，目前还没有解决。

## ACID

事务和ACID特性大家已经足够熟悉了，同时也是关系型数据库最大的优势，这里就不展开说ACID了。

## DBMS 数据模型

数据模型，即组织数据的方式。即使是一样的数据，组织的方式不同，也会产生差异。

### 网状模型

数据之间的关系可以交错，形成一个网状的模型。其实也就是多对多的关系。

### 层次模型

数据之间形成了一个树状的结构，也就是一对多的关系。

### 关系模型

所有数据都是一张二维表，具体的内容可以参照《数据库导论》。实际上关系模型并没有想象的那么简单。

## 关键技术

### SQL执行

SQL到达数据库后：
- 解析 SQL，生成AST（抽象语法树）
- 到达优化器，决定如何执行
- 到达执行器，从文件中读写数据，同时写入日志，最后返回结果

### SQL引擎-Parser

分为 词法分析、语法分析、语义分析 等步骤。

> 感觉这部分是编译原理搬过来的。是否所有涉及结构化语言分析的都可以套用这套理论？

### SQL引擎-Optimizer

一条语句，有不同的方式去做。优化器可以判断哪种方式最优。

- 基于规则的优化（RBO Rule Base Optimizer）
- 表连接优化
	- 总是小表先进行连接
- Scan优化
	- 唯一索引
	- 普通索引
	- 全表扫描

索引：辅助数据库进行查找、更新的数据结构。最常用B+树。

- 基于代价的优化（CBO Cost Base Optimizer）选择代价最低的方案执行。

> 内部实现非常复杂，这部分感觉和编译原理当中的优化部分也很接近。

### SQL引擎-Executor

火山模型：

每个Operator调用Next操作，访问下层Operator，获得下层Operator返回的一行数据，计算后返回给上层。

优点：每个算子独立抽象实现，相互之间没有耦合，逻辑结构简单

缺点：每计算一条数据有多次函数调用开销，导致CPU效率不高。

向量化：每次计算返回一批数据。函数调用次数降低为$\frac{1}{n}$，CPU cache命中率更高，可以利用CPU提供的SIMD（Single Instruction Multi Data）机制。

编译执行：将所有的操作封装到一个函数里面，函数调用的代价大大降低。如LLVM动态编译执行技术。

### 存储引擎-InnoDB

主要是Buffer pool和B+树，详细看我的数据库笔记。

### 事务引擎

提供ACID。

Atomicity，使用Undo Log进行事务回退，从而实现原子性。

Consistency一致性，一般由业务实现。

Isolation 与 锁，加锁防止数据读写冲突；MVCC，存储数据的多版本，不阻塞读写，降低死锁概率，实现一致性读。

Durability 与 Redo Log。