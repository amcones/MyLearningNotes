## 性能优化

性能优化指的是，优化掉不必要的开销，充分利用计算资源。哪怕是很小的优化，乘以庞大的机器数也会有显著的提升。

### 性能优化的层面

平时大多数人都只会考虑业务层的优化，这是因为业务层离程序员是最近的。然而，在实际生产当中，为了适应不同的需求，对语言运行时进行优化也未尝不可。

- 业务层优化
	- 具体问题具体分析
	- 容易获得较大性能收益
- 语言运行时优化
	- 解决更通用的性能问题
	- 考虑更多场景
	- Tradeoffs
- 数据驱动
	- 自动性能分析工具——pprof
	- 依靠数据而非猜测
	- 首先优化最大瓶颈

### 性能优化与软件质量

作为一个软件工程专业的学生，软件质量是个再熟悉不过的词了。软件质量中，文档是极其重要的一环，也就是说软件质量≠代码质量。性能优化当中的软件质量有以下几个方面：

- 确保接口稳定的前提下改进
- 测试用例
- 文档：做了什么，没做什么，能达到什么效果
- 隔离：选项控制是否开启优化
- 可观测：必要的日志输出

## 自动内存管理

管理动态内存，也就是程序运行时根据需求**动态分配**的内存。自动内存管理（垃圾回收），由程序语言的运行时系统管理动态内存。

自动内存管理的作用：
- 避免手动管理内存，专注实现业务逻辑
- 保证内存使用**正确性**和**安全性**：double-free problem, use-after-free problem

三个任务：
- 为新对象分配空间
- 找到存活对象
- 回收死亡对象的内存空间

### 相关概念

- Mutator:业务线程，分配新对象，修改对象指向关系
- Collector:GC线程，找到存活对象，回收死亡对象的内存空间
- Serial GC:只有一个collector
- Parallel GC:支持多个collectors同时回收的GC算法
- Concurrent GC:mutator(s)和collector(s)可以**同时执行**
	- **Collectors必须感知对象指向关系的改变**

Serial GC和Parallel GC都需要暂停程序去做GC，Concurrent GC则可以一边GC一边跑业务线程。

### 评价GC算法

- 安全性(Safety)：不能回收存活的对象 **基本要求**
- 吞吐率(Throughtput):$1-\frac{GC时间}{程序执行总时间}$ **花在GC上的时间**
- 暂停时间(Pause time): stop the world (STW) **业务是否感知**
- 内存开销(Space overhead) **GC元数据开销**

### 追踪垃圾回收

- 对象被回收的条件：指针指向关系不可达的对象
- 标记根对象
	- 静态变量、全局变量、常量、线程栈等
- 标记：找到可达对象
	- 求指针指向关系的传递闭包：从根对象出发，找到所有可达对象
- 清理：所有不可达对象
	- 复制存活对象到另外内存空间(Copying GC)
	- 将死亡对象的内存标记为“可分配”(Mark-sweep GC)
	- 移动并整理存活对象(Mark-compact GC，而 Compact GC就是原地整理)
- 根据对象的生命周期，使用不同的标记和策略

#### 分代GC(Generational GC)

> Java用的就是这个

- 分代假说(Generational hypothesis): most object die young
- 每个对象都有年龄：经过GC的次数
- 目的：对年轻和老年的对象，制定不同的GC策略，**降低整体内存管理的开销**
- 不同年龄的对象处于heap的不同区域
- 年轻代由于**存活对象很少**，采用copying collection，GC吞吐率很高
- **老年代趋于一直活着，反复复制开销大**，可以采用mark-sweep collection

### 引用计数

> Go 的方案

- 每个对象都有一个与之关联的引用数目
- 对象引用数等于0也就死亡
- 优点
	- 内存管理的操作被平摊到程序执行过程中
	- 内存管理不需要了解runtime的实现细节：C++智能指针
- 缺点
	- 开销较大，需要**原子操作**保证引用计数操作的**原子性**和**可见性**
	- 无法回收环形数据结构——weak reference
	- 内存开销：每个对象都引入额外的内存空间存储饮用数目
	- 回收内存时依然可能引发暂停

## Go内存管理 & 编译器优化思路

### Go内存分配

- 目标：为对象在heap上分配内存
- 提前将内存分块
	- 调用系统调用mmap()向OS申请一大块内存，例如4MB
	- 先将内存划分为大块，例如8KB，称作mspan
	- 再将大块继续划分成**特定大小**的小块，用于对象分配
	- noscan mspan：分配不包含指针的对象——GC不需要扫描
	- scan mspan：分配包含指针的对象——GC需要扫描
- 对象分配：根据对象大小，分配合适的块

### 缓存

- TCMalloc：thread caching
- 每个p包含一个mcache用于快速分配
- mcache管理一组mspan
- 当mache中的mspan分配完毕，向mcentral申请带有未分配块的mspan
- 当mspan中没有分配的对象，缓存mspan而不是立刻释放归还给OS

### Go内存管理优化

- 对象分配非常高频，每秒分配GB级别内存
- 小对象占比较高
- Go内存分配比较耗时
	- 分配路线长
	- pprof：对象分配的函数是最频繁调用的函数之一

### 字节的优化方案：Balanced GC

- 每个g都绑定一大块内存（1kb），称作 goroutine allocation buffer (GAB)
- GAB 用于noscan类型的小对象分配：<128B
- 使用三个指针维护GAB：base,end,top
- Bump pointer(指针碰撞)风格对象分配
	- 无需和其它分配请求互斥
	- 分配动作简单高效
- 本质：**将多个小对象的分配合并成一次大对象的分配**
- 问题：GAB的对象分配方式会导致内存被延迟释放
- 方案：移动GAB中存活的对象
	- 当GAB总大小超过一定阈值，将GAB中存活的对象复制到另外分配的GAB中
	- 原先的GAB可以释放，避免内存泄漏
	- 本质：**用copying GC的算法管理小对象**

## 编译器和静态分析

### 编译器的结构

- 重要的系统软件
	- 识别符合语法和非法的程序
	- 生成正确且高效的代码
- 分析部分（前端front end）
	- 词法分析，生成词素（lexeme）
	- 语法分析，生成语法书
	- 语义分析，收集类型信息，进行语义检查
	- 中间代码生成，生成intermediate representation(IR)
- 综合部分（后端back end）
	- 代码优化，机器无关优化，生成优化后的IR
	- 代码生成，生成目标代码

可以发现，前端主要是固定的流程，真正有优化价值的是后端

### 静态分析

- **不执行程序代码**，推到程序的行为，分析程序的性质
- 控制流（Control flow）：程序执行的流程
- 数据流（Data flow）：数据在控制流上的传递
- 通过分析控制流和数据流，可以知道更多**关于程序的性质（properties）
- 根据这些性质优化代码

### 过程内分析和过程间分析

- 过程内分析：仅在过程内部进行分析
- 过程间分析：考虑过程调用时参数传递和返回值的数据流和控制流
- 过程间分析的问题
	- 需要通过**数据流分析**得知i的具体类型，才能知道i.foo()调用的是哪个foo()
	- 根据i的具体类型，**产生了新的控制流**，A.foo()，分析继续
	- 需要**同时**分析控制流和数据流——联合求解，比较复杂

### Go编译器优化

- 优点
	- 用户无感知
	- 通用性优化
- 现状
	- 采用的优化少
	- 编译时间较短，没有进行较复杂的代码分析和优化
- 编程优化的思路
	- 场景：面向后端长期执行任务
	- Tradeoff：**用编译时间换更高效的机器码**
- Beast mode
	- **函数内联**
	- **逃逸分析**
	- 默认栈大小调整
	- 边界检查消除
	- 循环展开
	- ...

### 函数内联(Inlining)

- 将被调用函数的函数体(callee)副本替换到调用位置(caller)上，同时重写代码以反映参数的绑定
- 优点
	- 消除函数调用开销，比如传递参数、保存寄存器
	- 简化过程间分析为过程内分析，帮助其它优化，比如**逃逸分析**
	- 效果很好，可以使用micro-benchmark快速验证和对比性能优化结果
- 缺点
	- 函数体变大，instruction cache(icache)不友好
	- 编译生成的Go镜像变大
- 大多数情况下是正向优化（除了递归）
- 内联策略
	- 调用和被调函数的规模
	- ...

### Beast Mode

- Go 函数内联收到限制较多
	- 语言特性，例如interface，defer等，限制了函数内联
	- 内联策略非常保守
- Beast mode：调整函数内联策略，使更多函数内联
	- 降低函数调用开销
	- 增加了其它优化的机会
- 开销
	- Go镜像增加～10%
	- 编译时间增加

### 逃逸分析

- 分析代码中指针的动态作用域：指针在何处可以被访问
- 大致思路
	- 从对象分配处出发，沿着控制流，观察对象的数据流
	- 若发现指针p在当前作用域s：
		- 作为参数传递给其他函数
		- 传递给全局变量
		- 传递给其他的goroutine
		- 传递给已逃逸的指针指向的对象
	- 则指针p指向的对象逃逸出s，反之则没有逃逸出s
- Beast mode：函数内联扩展了函数边界，更多对象不逃逸
- 优化：为逃逸对象可以在**栈上分配**
	- 对象在栈上分配和回收很快：移动sp
	- 减少在heap上的分配，降低GC负担

