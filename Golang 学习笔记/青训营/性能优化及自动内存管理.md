## 性能优化

性能优化指的是，优化掉不必要的开销，充分利用计算资源。哪怕是很小的优化，乘以庞大的机器数也会有显著的提升。

### 性能优化的层面

平时大多数人都只会考虑业务层的优化，这是因为业务层离程序员是最近的。然而，在实际生产当中，为了适应不同的需求，对语言运行时进行优化也未尝不可。

- 业务层优化
	- 具体问题具体分析
	- 容易获得较大性能收益
- 语言运行时优化
	- 解决更通用的性能问题
	- 考虑更多场景
	- Tradeoffs
- 数据驱动
	- 自动性能分析工具——pprof
	- 依靠数据而非猜测
	- 首先优化最大瓶颈

### 性能优化与软件质量

作为一个软件工程专业的学生，软件质量是个再熟悉不过的词了。软件质量中，文档是极其重要的一环，也就是说软件质量≠代码质量。性能优化当中的软件质量有以下几个方面：

- 确保接口稳定的前提下改进
- 测试用例
- 文档：做了什么，没做什么，能达到什么效果
- 隔离：选项控制是否开启优化
- 可观测：必要的日志输出

## 自动内存管理

管理动态内存，也就是程序运行时根据需求**动态分配**的内存。自动内存管理（垃圾回收），由程序语言的运行时系统管理动态内存。

自动内存管理的作用：
- 避免手动管理内存，专注实现业务逻辑
- 保证内存使用**正确性**和**安全性**：double-free problem, use-after-free problem

三个任务：
- 为新对象分配空间
- 找到存活对象
- 回收死亡对象的内存空间

### 相关概念

- Mutator:业务线程，分配新对象，修改对象指向关系
- Collector:GC线程，找到存活对象，回收死亡对象的内存空间
- Serial GC:只有一个collector
- Parallel GC:支持多个collectors同时回收的GC算法
- Concurrent GC:mutator(s)和collector(s)可以**同时执行**
	- **Collectors必须感知对象指向关系的改变**

Serial GC和Parallel GC都需要暂停程序去做GC，Concurrent GC则可以一边GC一边跑业务线程。

### 评价GC算法

- 安全性(Safety)：不能回收存活的对象 **基本要求**
- 吞吐率(Throughtput):$1-\frac{GC时间}{程序执行总时间}$ **花在GC上的时间**
- 暂停时间(Pause time): stop the world (STW) **业务是否感知**
- 内存开销(Space overhead) **GC元数据开销**

### 追踪垃圾回收

- 对象被回收的条件：指针指向关系不可达的对象
- 标记根对象
	- 静态变量、全局变量、常量、线程栈等
- 标记：找到可达对象
	- 求指针指向关系的传递闭包：从根对象出发，找到所有可达对象
- 清理：所有不可达对象
	- 复制存活对象到另外内存空间(Copying GC)
	- 将死亡对象的内存标记为“可分配”(Mark-sweep GC)
	- 移动并整理存活对象(Mark-compact GC，而 Compact GC就是原地整理)
- 根据对象的生命周期，使用不同的标记和策略

#### 分代GC(Generational GC)

> Java用的就是这个

- 分代假说(Generational hypothesis): most object die young
- 每个对象都有年龄：经过GC的次数
- 目的：对年轻和老年的对象，制定不同的GC策略，**降低整体内存管理的开销**
- 不同年龄的对象处于heap的不同区域
- 年轻代由于**存活对象很少**，采用copying collection，GC吞吐率很高
- **老年代趋于一直活着，反复复制开销大**，可以采用mark-sweep collection

### 引用计数

> Go 的方案

- 每个对象都有一个与之关联的引用数目
- 对象引用数等于0也就死亡
- 优点
	- 内存管理的操作被平摊到程序执行过程中
	- 内存管理不需要了解runtime的实现细节：C++智能指针
- 缺点
	- 开销较大，需要**原子操作**保证引用计数操作的**原子性**和**可见性**
	- 无法回收环形数据结构——weak reference
	- 内存开销：每个对象都引入额外的内存空间存储饮用数目
	- 回收内存时依然可能引发暂停

## Go内存管理 & 编译器优化思路

### Go内存分配

- 目标：为对象在heap上分配内存
- 提前将内存分块
