大家都有做过需要繁杂判断的大讨论题，随着规则的增加代码会变得越来越复杂，同时也意味着可维护性、可靠性直线下降。于是，将规则判断这部分逻辑抽离出业务代码，自然而然地成为了一个新的需求。

## 规则引擎

### 定义

将业务决策从程序代码中分离出来，并使用预定义的语义模块编写业务决策。

### 场景

- 风控对抗
- 活动策略运营
- 数据分析和清洗

### 组成部分

- 数据输入
- 规则理解
- 规则执行

## 编译原理

编译原理本就是一门分析词法、语法的课程，与规则引擎的需求十分类似。所以我们可以使用编译原理的相关知识去构建一个规则引擎。此前我认为编译原理只是一个八股学科，没想到在业务中还有这种使用方式。

### 词法分析 Lexical Analysis

词法分析就是把源代码字符串转换为词法单元(Token)的过程。

如何识别Token？**有限自动机（Finite-State Automaton）**

有限自动机就是一个状态机，在任何一个状态，基于输入的字符，都能做一个确定的状态转换。

> 这里的状态是什么？通过一系列中间状态的转移后，最终得到一个token的状态，以此实现词法分析。

### 语法分析 Syntax Analysis

在词法分析基础上，识别表达式的语法结构

比如一个操作符需要左操作数和右操作数

**抽象语法树 Abstract Syntax Tree** ：表达式的语法结构用树表示，每个节点（子树）是一个语法单元，这个单元的构成规则就叫做“语法”。每个节点可以有下级节点。

上下文无关语法 Context-Free Grammar：无需考虑上下文，就可以判断正确性。可以使用巴科斯范式（BNF）来表达。巴科斯使用递归下降算法(Recursive Descent Parsing)，自顶向下构造语法树，不断的对Token进行语法展开（下降），过程中可能遇到递归。

> 通过递归下降算法，实际上根据递归深度也实现了优先级。优先级高的会先被判断，如果不满足就向下递归，直到找到符合的语法。

类型检查：
- 类型综合：根据子表达式的类型构造出父表达式的类型。
- 编译时检查&运行时检查：可以在构造语法树的阶段，也可以在执行时的阶段。
	- 编译时：提前声明参数的类型，在构建语法树过程中检查
	- 运行时检查：根据执行时的参数输入的值类型，在执行过程中检查。

## 设计规则引擎

### 设计目标

- 词法分析
	- 词法（合法Token）
	- 运算符
	- 数据类型
	- 优先级
- 设计词法分析的状态机
- 语法分析
	- 优先级的表达
	- 语法树结构：一元运算符，二元运算符，括号。。。（可以使用二叉树实现）
- 语法树执行与类型检查
	- 语法树执行：**后序遍历**语法树，即先执行左子树，再执行右子树，最后根据根节点的操作符得到根节点的值
	- 类型检查
		- 检查时机：执行时检查/编译时检查
		- 检查方法：对一个节点的左右子节点执行完后，分别校验左右子节点的类型是否符合**对应操作符的类型检查预设规则**，比如：'>'要求左右节点值都存在且为int或float，'!'要求左节点为空且右节点为bool。

## 实现规则引擎


