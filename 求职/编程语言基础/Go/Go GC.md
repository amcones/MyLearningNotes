V1.3之前：标记清除算法
V1.5：三色并发标记法
V1.8：混合写屏障

## 标记清除算法

- 标记阶段：从根对象出发，查找并标记堆中所有存活的对象
- 清除阶段：遍历堆中所有对象，回收未被标记的对象，将对应的内存加入空闲链表

缺点：
1. STW，需要暂停程序运行（大STW）
2. 清除数据会产生内存碎片

## 三色标记

有点像BFS。通过BFS，在过程中把所有对象染成三色中的一种，最后删除白色对象。

仍然需要STW，因为两个条件会破坏GC的正确性：
1. 某个黑色对象引用白色对象
2. 从灰色对象出发，到达白色对象的、未被访问过的路径遭到破坏

## 屏障技术

破坏两个必要条件就可以保证对象不丢失。需要达成两种三色不变性中的一种：

1. 强三色不变性
黑色对象不会指向白色对象。
2. 弱三色不变性
黑色对象指向的白色对象，必须包含一条从灰色对象经由多个白色对象的可达路径。

屏障技术在并发或增量标记过程中保证三色不变性。保证代码描述中对内存操作的顺序性，既不会在编译器被编译器调整，也不会在运行时被CPU乱序执行打乱。是在用户创建对象、读取对象、更新对象指针时执行的一段代码。

Go采用Dijkstra的插入写屏障和Yuasa的删除写屏障。

### 插入写屏障

> 在黑色对象引用一个白色对象时，将白色对象改为灰色

满足强三色不变性。

为了避免性能开销，栈没有启动写屏障，所以需要STW（防止扫描期间一直产生新的引用）重新扫描所有栈空间进行标记。

### 删除写屏障

> 在灰色对象引用白色对象时，用户将这个引用关系删除，触发写屏障仍然标记被删除的对象为灰色

满足弱三色不变性。

不需要重新扫描，但回收精度低，一个对象的最后一个引用指针即使被删除了，仍能够在本轮垃圾回收存在，需要等到下一轮GC才能够被清除。

### 混合写屏障

对正在被覆盖的对象进行着色，且如果当前栈未扫描完成，则同样对指针进行着色。

主要是对栈上所有对象标记为黑色，GC期间栈上新建的对象也标记为黑色。

## 内存泄漏

Go依然会发生内存泄漏。

比如
1. 一个全局变量被某个变量不经意间引用且忽略释放，则永远不会被释放
2. Goroutine泄漏