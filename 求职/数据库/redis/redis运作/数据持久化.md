两种方式：
1. RDB（Redis Database），记录Redis某个时刻的全部数据，就是数据快照，直接保存二进制数据到磁盘，后续加载RDB文件恢复数据。
2. AOF(Append Only File)，记录执行的每条命令，就是记录操作日志。

可以同时开启（最可靠），此时优先AOF，或者单独开RDB（能接受几分钟的丢失）。

## RDB

在redis.conf中配置。语法是save interval num，表示每隔interval秒，至少有num条写数据操作，就激活RDB持久化。可以有多条配置，并集。Redis默认有3条配置，默认开启RDB持久化。

可以配置文件存在哪里。

### 执行时机

1. 主动执行save命令，如果写入RDB时间过长会阻塞主线程。
2. 主动执行bgsave命令，会创建一个子线程保存RDB，不阻塞主线程。
3. 达到持久化配置阈值
4. 程序正常关闭时执行

redis使用写时复制，减少创建子进程的开销。

## AOF

同样在redis.conf配置，把appendonly设置为yes即可打开。

Redis提供3种刷盘策略：
1. appendfsync always，每次请求都刷入AOF，非常慢非常安全
2. appendfsync everysec，每秒刷一次，可能会丢失1秒数据
3. appendfsync no，不主动刷盘，让操作系统自己刷，Linux一般30秒刷一次，性能影响小。

### 写入AOF细节

1. 写入AOF缓存，是一个sds数据
2. 缓存数据刷入磁盘缓冲区，有4个时机会调用函数写入操作系统缓冲区：
	1. 处理完事件处理后，等待下一次事件到来前
	2. 周期函数serverCron
	3. 服务器退出之前的准备工作时
	4. 通过配置指令关闭AOF时
3. 刷盘，调用系统的flush函数

### AOF重写

AOF体积过大时，自动在后台fork一个子进程，对AOF进行重写，合并相同key的操作。重写过程中，不但会将新的操作记录写在AOF缓冲区，也会记录在AOF重写缓冲区。（防止Redis崩溃丢失），一旦新AOF文件创建完毕，就重写缓冲区内容，追加到新的AOF文件，再替换原有的AOF文件。

同时满足两个条件重写：
1. 相比上次重写时候数据增长超过100%
2. 超过64M

## 混合持久化

在重写AOF数据时，把当前状态保存为RDB二进制内容，写入AOF文件，再把重写缓冲区的内容追加到AOF文件。还是属于AOF。

判断文件开头是否有“REDIS”来判断是否是开启了混合持久化的AOF文件。

可以降低AOF重写的性能损耗，以及降低AOF的存储空间，代价是降低AOF文件可读性。

## MP-AOF方案

Redis7.0优化了AOF重写方案。

AOF劣势：
1. 占用主进程CPU时间，重写期间进程间读写数据，子进程结束后写入临时文件都需要消耗CPU时间
2. 额外内存开销
3. 额外磁盘开销

MP-AOF将原本一个AOF变成多个AOF文件配合，核心由两部分组成：
1. BASE AOF，记录基本命令
2. INCR AOF，记录重写过程中新增的操作命令

现在重写阶段在主线程写入AOF缓冲区即可，缓冲区数据最终落入新打开的INCR AOF文件，子进程将BASE AOF重写并生成新文件。写完之后，更新manifest文件清单文件，描述当前有效的BASE AOF和INCR AOF是哪个。旧的文件标记为HISTORY AOF，之后会被redis异步删掉。