Redis核心模块一直是单线程，但一些辅助模块多线程：
- 复制模块
- 某些异步流程从4.0开始多线程，如UNLINK、FLUSHALL ASYNC、FLUSHDB ASYNC等非阻塞的删除操作
- 网络I/O解包

## 为何单线程

官方认为Redis执行不会成为瓶颈，而是在网络I/O，处理逻辑多线程不会有多大收益。

1. 多线程引入复杂性巨大，程序调试更加复杂和麻烦
2. 多线程带来额外成本，包括
	1. 上下文切换
	2. 同步机制开销
	3. 线程本身占内存

## 单线程为什么快

1. 大部分操作在内存上完成
2. 数据结构做了大量优化
3. 采用多路复用，能并发处理大量客户请求

主要看瓶颈也就是I/O。socket默认是阻塞模式，可能发生在accept和recv的时候。所以Redis将socket设置为非阻塞式，并且使用I/O多路复用来监听操作是否就绪。

Redis做了一层包装，叫做Reactor模型。本质就是监听各种事件，当事件发生时分发给不同的处理器。

Redis实现了一个AE库，会根据系统内核版本自动选择select，epoll，kqueue等。

首先监听端口，创建监听套接字，然后调用绑定对应的接受处理函数，绑定之后等到客户端连接请求发回来，就可以关联到这个处理函数。main函数调用initServer之后，就开始在aeMain函数中开始一个EventLoop事件循环，通过epoll_wait()等待连接到达。

连接到达后，事件循环就能收到信息，但无法确定能无阻塞读到完整的请求包，所以仍然放到同一个epoll实例当中，让内核去通知fd就绪，解决recv阻塞等待问题。

## 多线程

Redis6.0多线程不是默认开启，需要在redis.conf中配置。

多线程主要负责：读取并解析指令以及回包

单线程下一个线程完成读取，解析，执行，将回包放入客户端缓冲区

多线程下，将不同的client放入clients_pending_read任务队列，后续通过Round-Robin轮询负载均衡策略把这些client分给其他IO线程和主线程进行读取和解析

回包的时候，也是利用Round-Robin轮询负载均衡策略把等待回包队列中的任务连续均匀地分配给IO线程各自的本地任务队列和主线程，主线程轮询等待所有IO线程完成回包任务。