1. 聊聊TCP
	TCP是传输层的协议，是一种基于字节流的可靠的面向连接的协议。TCP头部最少20个字节，其中有一些控制位，如ACK，SYN，RST，FIN。
	在linux中，一个TCP连接就是一个文件，占用一个fd，如果用光了就会报too many open files。
2. 聊聊三次握手四次挥手
	连接过程：首先服务器在某个端口上监听，客户端随机一个序列号(client_isn)加上SYN发给服务器，服务器收到后随机一个序列号(server_isn)加上SYN和ACK发给客户端，客户端收到后再回一个ACK，确认号为server_isn+1。只有第三次握手是可以带数据的。
	三次握手的原因首先是防止旧的连接重新初始化造成混乱，其次是同步双方的初始序列号，第三是避免服务端每次收到一个SYN不能确定客户端有没有收到回复的ACK，只能主动建一个连接。
	断开过程：双方都可以发起断开，先发一个FIN，接收方发一个ACK，处理完后再发FIN，发起方最后发一个ACK就断开了，主动发起方进入TIME_WAIT。TIME_WAIT是因为可能FIN先到了，当中发的报文丢了或者还没到，就要重传，重传完了再重传FIN，收到FIN就重置TIME_WAIT。
	状态机：一开始双方处于CLOSE，服务端首先进入LISTEN，客户端发完SYN进入SYN_SENT，服务端收到进入SYN_RCVD，客户端收到SYN+ACK后进入ESTABLISHED，服务端收到ACK后进入ESTABLISHED。断开时，主动方发完FIN进入TIME_WAIT_1，被动方收到进入CLOSED_WAIT，主动方收到ACK进入TIME_WAIT_2，被动方处理完发送FIN进入LAST_ACK，主动方收到FIN发送ACK并进入TIME_WAIT，被动方直接CLOSE，主动方等完两个MSL再CLOSE。
3. 聊聊TCP重传机制
	TCP主要有两种重传机制，分别是超时重传和快速重传。超时重传是等了RTO没收到ACK就重传，这可能是发送的包丢了，也可能是ACK包丢了。快速重传则是连续发了三个包收到相同ACK报文，也就是接收方没有接收到要收的包，就进行重传。重传有选择重传和全部重传等方案。
4. 聊聊TCP滑动窗口
	发送方和接收方都会维护一个缓冲区叫做窗口，通过窗口大小来控制发送方发送数据的大小。有了这个缓冲区，就不用每发一个包都要等ACK，而是尽可能填充窗口，一起等ACK。同时发送方维护的发送窗口里保存着已经发送但还没有ACK的报文，重传的时候就可以直接发。
5. 聊聊TCP流量控制
	TCP根据接收方的窗口大小来决定发送方发送的量。为了避免接收方发送ACK通知发送方窗口非0的报文丢失造成死锁（ACK不会重传），发送方设置计时器，超时就发送窗口探测报文让接收方发窗口大小。
6. 聊聊TCP拥塞控制
	拥塞控制是为了避免在网络环境拥堵时发送方仍不断发送数据，加剧拥堵。维护一个拥塞窗口，发送窗口的大小为min(拥塞窗口，接收窗口)。只要发送方没有在规定时间内收到ACK就认为发生拥堵，有四个控制算法：
	1. 慢启动：刚建立完连接，慢慢增加拥塞窗口大小。每收到一个ACK，cwnd就+1。但是由于收到的ACK数量等于发送的报文数量，cwnd就+ACK，相当于翻倍，所以是指数增长。当达到慢启动门限ssthresh，就使用拥塞避免算法。
	2. 拥塞避免：每收到一个ACK，cwnd增加1/cwnd，也就是变为线性增长。
	3. 拥塞发生：超时重传时ssthresh设为cwnd/2，cwnd重置为1。快速重传把cwnd设为一半，把ssthresh设为cwnd，然后进入快速恢复。
	4. 快速恢复：此时已经收到3个ACK，cwnd=ssthresh+3。如果重发再收到重复的ACK就把cwnd+1，如果收到新的ACK，就把cwnd设为ssthresh，恢复到拥塞避免。
7. 聊聊CS144
	主要是一个自底向上的设计方法，首先设计可靠字节流。我使用了双端队列来作为数据结构，只要保证放进去的顺序和读出来的顺序是一样的即可。然后是实现一个流重组器，把收到的乱序报文重组后放入字节流。我使用了一个环形数组，这样下标和字节一一对应，便于实现。然后就是实现一个receiver和一个sender，receiver的细节有怎么发送ack，怎么管理窗口大小等。sender的细节有怎么维护窗口，以及超时重传。