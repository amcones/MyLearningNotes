这次主要是实现TCP当中的接收方。但在这之前，需要实现一个转换器。

我们都知道，TCP当中报文头的空间很宝贵。事实上，用来标记报文头部编号的数（就是传给上一个实验，流重组器的那个）只有32位的空间，$2^{32}$个字节是4GB，我们下一部电影就远不止这个数了。所以传给流重组器的编号是64位的，我们就需要实现一个转换器，在32位的报文头编号和64位的绝对编号之间进行转换。同时，处于安全性的考虑，报文头编号是从一个随机数`ISN`开始的，而绝对编号则符合我们正常的逻辑，从0开始。

64位到32位的转换，只需要将`ISN`加上绝对编号，多的直接溢出，相当于对$2^{32}$取模。

而32位到64位的转换是不唯一的，因为有很多数对$2^{32}$取模等于同一个值。而程序会给我们一个`checkpoint`，我们需要找最接近`checkpoint`的数。这有很多办法，但最直观的就是先求出32位的编号与`checkpoint`之间的距离。数轴上距离一个点的距离相同的点有两个，我们取其中更近的那个即可。我个人想尽可能避免显式的类型转换，所以代码主要是进行了隐式的转换，这点需要注意。

需要特别注意的是，像`SYN`，`FIN`这些特殊标志也是占用了一个绝对编号，这在之后发送`ackno`时要特别注意。

终于可以写接收器了。接收器的代码其实很简单，只要对编号思路清晰，特别关注下两个特殊标志即可。这里因为之前`tests`中代码的bug，会导致我的代码不断超时或是报错。本来以为是前面的实现有问题或者效率太低改了两天，最后才看到有新的commit。这个故事告诉我们，没事就`git pull`一下。