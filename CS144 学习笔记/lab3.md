逐渐进入了CS144的高潮，我们这次要写一个TCP发送方。

被动接受总是容易的，但主动发出就要更为复杂。

发送方需要做这些事：

- 跟踪接收方的窗口（接收方返回的响应当中包含了确认号和窗口大小），这样就知道对方需要什么数据
- 尽可能填满接收方的窗口，从字节流中读出数据并创建新的TCP报文段，同时视情况添加`SYN`和`FIN`标志。发送方应该**一直发送数据**直到窗口满了或者数据发完了。
- 跟踪那些已经发送了但没有收到确认的报文，我们称为"未完成"报文。
- 重新发送超时的未完成报文

实际上，现实TCP协议当中超时重传要更为复杂（有很多方案）。但在这个实验里进行了简化，只要关注最早发送的报文是否超时，如果超时就重传。

超时的时间叫做`RTO`，它是会变的，但它的初始值固定。

关于计时器的实现这里不展开了，主要就是一堆符合直觉的讨论。需要注意各种细节去控制各种值。

值得一提的是，这次实验与往年有些许不同：
1. 往年发送报文段是将其push到一个队列中，而今年是作为了一个optional函数的返回值。
2. 不再特别提出TCP sender的状态。

## 正题

前面bb的都是实验文档的内容，如果只看这个写很容易一脸懵逼。所以，这里给出几个着手的建议：
1. 面向样例编程
虽然大多数情况下这是个贬义词，但当我们无法入手的时候，可以尝试。当然前提是样例的质量够高。
2. 从简单的做起
乍一看有一堆需求一堆细节，但我们可以从最简单的开始。对于这个lab来说，我们知道要写一个TCPSender，那么就先写正常情况下（不丢包，不超时，不重叠）一个报文发出去的逻辑，然后再根据需求（样例）增加功能。
3. 多次commit
这点实验文档里也写了，多次commit有助于理清自己实现的逻辑，避免写多了自己都忘了写了啥。（我一开始忘了这件事，等想起来的时候就感觉找不准commit的时机了，只能再写下去）
4. 开始写才是最重要的
last but no the least, 只有你开始写了，你才能写完。不用执着于一发bug free，这是不现实的。但是开始写之前，**必须搞清要求**。