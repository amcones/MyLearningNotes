## 前言

学了这么久C++了，却没有拿C++写过一个项目，以至于连`Makefile`的基本语法都不会。好在还有时间，“朝闻道，夕死可矣。”

如上文所述，`Makefile`是用来**自动化构建**C++项目的。当一个C++项目包含有上千个源文件，各个文件的依赖关系不同。假如修改了其中一个，难道我们需要重新编译整个项目吗？如何定义编译的先后顺序？`Makefile`正是用来解决这些问题的。

>虽然`Makefile`的语法本身被人所诟病，而且在现代使用的更多的是`CMake`，但我们仍有理由学习它（而且它的难度并不高）。

## 关于程序的编译和链接

大家都知道，C/C++在**编译阶段**都是先把源文件编译成中间代码文件，在Windows下为`.obj`文件，在UNIX下是`.o`文件，即Object File。而在**链接阶段**则是将这些Object File合成可执行文件。

编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置。（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件对应一个中间目标文件（`.o`或`.obj`）。

链接时，主要是链接函数和全局变量。编译器并不管函数所在的源文件，只管函数的中间目标文件。当中间目标文件太多，而在链接阶段需要明显地指出中间目标文件名，可以给中间文件打个包，在Windows下这种包叫“库文件”(Library File)，也就是`.lib`文件，在UNIX下，是Archive File，也就是`.a`文件。

总结起来就是，编译器首先生成中间目标文件，再由中间目标文件生成执行文件。在编译的时候，编译器只检测语法正确，函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有Object FIle中找寻函数的实现。如果找不到，就会报链接错误码（Linker Error），在VC下这种错误一般是：`Link 2001错误`，意思是链接器未能找到函数的实现，需要指定函数的Object File。

[[Makefile介绍]]